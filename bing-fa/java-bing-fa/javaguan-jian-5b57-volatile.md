## 1. volatile简介

在上一篇文章中我们深入理解了java关键字\[synchronized\]\([https://juejin.im/post/5ae6dc04f265da0ba351d3ff\)，我们知道在java中还有一大神器就是关键volatile，可以说是和synchronized各领风骚，其中奥妙，我们来共同探讨下。](https://juejin.im/post/5ae6dc04f265da0ba351d3ff%29，我们知道在java中还有一大神器就是关键volatile，可以说是和synchronized各领风骚，其中奥妙，我们来共同探讨下。)

通过上一篇的文章我们了解到synchronized是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用

synchronized。\[Java内存模型\]\([https://juejin.im/post/5ae6d309518825673123fd0e\)告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普](https://juejin.im/post/5ae6d309518825673123fd0e%29告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普)

通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。

现在我们有了一个大概的印象就是：\*\***被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。**\*\*

## 2. volatile实现原理

volatile是怎样实现了？比如一个很简单的Java代码：

```
instance = new Instancce()  // instance是volatile变量
```

在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出\*\***Lock前缀的指令**\*\*（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个\*\***Lock**\*\*指令肯定有神奇的地方，那么Lock前缀的指令在多核处理器下会发现什么事情了？

主要有这两个方面的影响：

1. 将当前处理器缓存行的数据写回系统内存；

2. 这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行

的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现\*\*缓存一致性\*\*协议，\*\***每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**\*\*了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：

1. Lock前缀的指令会引起处理器缓存写回内存；

2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；

3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。

